// This file was generated by counterfeiter
package fake_gatherer

import (
	"sync"

	"github.com/cloudfoundry-incubator/executor"
	"github.com/cloudfoundry-incubator/rep/gatherer"
	"github.com/cloudfoundry-incubator/runtime-schema/models"
)

type FakeSnapshot struct {
	ListContainersStub        func(tags executor.Tags) []executor.Container
	listContainersMutex       sync.RWMutex
	listContainersArgsForCall []struct {
		tags executor.Tags
	}
	listContainersReturns struct {
		result1 []executor.Container
	}
	GetContainerStub        func(guid string) (*executor.Container, bool)
	getContainerMutex       sync.RWMutex
	getContainerArgsForCall []struct {
		guid string
	}
	getContainerReturns struct {
		result1 *executor.Container
		result2 bool
	}
	ActualLRPsStub        func() []models.ActualLRP
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct{}
	actualLRPsReturns     struct {
		result1 []models.ActualLRP
	}
	TasksStub        func() []models.Task
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct{}
	tasksReturns     struct {
		result1 []models.Task
	}
	LookupTaskStub        func(guid string) (*models.Task, bool, error)
	lookupTaskMutex       sync.RWMutex
	lookupTaskArgsForCall []struct {
		guid string
	}
	lookupTaskReturns struct {
		result1 *models.Task
		result2 bool
		result3 error
	}
}

func (fake *FakeSnapshot) ListContainers(tags executor.Tags) []executor.Container {
	fake.listContainersMutex.Lock()
	fake.listContainersArgsForCall = append(fake.listContainersArgsForCall, struct {
		tags executor.Tags
	}{tags})
	fake.listContainersMutex.Unlock()
	if fake.ListContainersStub != nil {
		return fake.ListContainersStub(tags)
	} else {
		return fake.listContainersReturns.result1
	}
}

func (fake *FakeSnapshot) ListContainersCallCount() int {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	return len(fake.listContainersArgsForCall)
}

func (fake *FakeSnapshot) ListContainersArgsForCall(i int) executor.Tags {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	return fake.listContainersArgsForCall[i].tags
}

func (fake *FakeSnapshot) ListContainersReturns(result1 []executor.Container) {
	fake.ListContainersStub = nil
	fake.listContainersReturns = struct {
		result1 []executor.Container
	}{result1}
}

func (fake *FakeSnapshot) GetContainer(guid string) (*executor.Container, bool) {
	fake.getContainerMutex.Lock()
	fake.getContainerArgsForCall = append(fake.getContainerArgsForCall, struct {
		guid string
	}{guid})
	fake.getContainerMutex.Unlock()
	if fake.GetContainerStub != nil {
		return fake.GetContainerStub(guid)
	} else {
		return fake.getContainerReturns.result1, fake.getContainerReturns.result2
	}
}

func (fake *FakeSnapshot) GetContainerCallCount() int {
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	return len(fake.getContainerArgsForCall)
}

func (fake *FakeSnapshot) GetContainerArgsForCall(i int) string {
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	return fake.getContainerArgsForCall[i].guid
}

func (fake *FakeSnapshot) GetContainerReturns(result1 *executor.Container, result2 bool) {
	fake.GetContainerStub = nil
	fake.getContainerReturns = struct {
		result1 *executor.Container
		result2 bool
	}{result1, result2}
}

func (fake *FakeSnapshot) ActualLRPs() []models.ActualLRP {
	fake.actualLRPsMutex.Lock()
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct{}{})
	fake.actualLRPsMutex.Unlock()
	if fake.ActualLRPsStub != nil {
		return fake.ActualLRPsStub()
	} else {
		return fake.actualLRPsReturns.result1
	}
}

func (fake *FakeSnapshot) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeSnapshot) ActualLRPsReturns(result1 []models.ActualLRP) {
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []models.ActualLRP
	}{result1}
}

func (fake *FakeSnapshot) Tasks() []models.Task {
	fake.tasksMutex.Lock()
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct{}{})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub()
	} else {
		return fake.tasksReturns.result1
	}
}

func (fake *FakeSnapshot) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeSnapshot) TasksReturns(result1 []models.Task) {
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []models.Task
	}{result1}
}

func (fake *FakeSnapshot) LookupTask(guid string) (*models.Task, bool, error) {
	fake.lookupTaskMutex.Lock()
	fake.lookupTaskArgsForCall = append(fake.lookupTaskArgsForCall, struct {
		guid string
	}{guid})
	fake.lookupTaskMutex.Unlock()
	if fake.LookupTaskStub != nil {
		return fake.LookupTaskStub(guid)
	} else {
		return fake.lookupTaskReturns.result1, fake.lookupTaskReturns.result2, fake.lookupTaskReturns.result3
	}
}

func (fake *FakeSnapshot) LookupTaskCallCount() int {
	fake.lookupTaskMutex.RLock()
	defer fake.lookupTaskMutex.RUnlock()
	return len(fake.lookupTaskArgsForCall)
}

func (fake *FakeSnapshot) LookupTaskArgsForCall(i int) string {
	fake.lookupTaskMutex.RLock()
	defer fake.lookupTaskMutex.RUnlock()
	return fake.lookupTaskArgsForCall[i].guid
}

func (fake *FakeSnapshot) LookupTaskReturns(result1 *models.Task, result2 bool, result3 error) {
	fake.LookupTaskStub = nil
	fake.lookupTaskReturns = struct {
		result1 *models.Task
		result2 bool
		result3 error
	}{result1, result2, result3}
}

var _ gatherer.Snapshot = new(FakeSnapshot)
